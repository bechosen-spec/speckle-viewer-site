"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertBasicStringToDocument = exports.documentToBasicString = exports.isDocEmpty = void 0;
const _lodash_1 = require("#lodash");
/**
 * Used to match URLs that can appear anywhere in a string, not perfect, but crafting a perfect
 * URL regex is quite complex and we only need this for legacy comments
 */
const MID_STRING_URL_RGX = /https?:\/\/\S+/gi;
/**
 * Check whether a doc is empty
 */
function isDocEmpty(doc) {
    if (!doc)
        return true;
    return (0, _lodash_1.trim)(documentToBasicString(doc, 1)).length < 1;
}
exports.isDocEmpty = isDocEmpty;
/**
 * Convert document to a basic string without all of the formatting, HTML tags, attributes etc.
 * Useful for previews or text analysis.
 * @param stopAtLength If set, will stop further parsing when the resulting string length
 * reaches this length. Useful when you're only interested in the first few characters of the document.
 */
function documentToBasicString(doc, stopAtLength = undefined) {
    if (!doc)
        return '';
    const recursiveStringBuilder = (doc, currentString) => {
        var _a;
        if ((0, _lodash_1.isNumber)(stopAtLength) && currentString.length >= stopAtLength) {
            return currentString;
        }
        if (doc.text) {
            currentString += doc.text;
        }
        // if mention, add it as text as well
        if (doc.type === 'mention' && ((_a = doc.attrs) === null || _a === void 0 ? void 0 : _a.label) && doc.attrs.id) {
            currentString += '@' + doc.attrs.label;
        }
        for (const contentDoc of doc.content || []) {
            currentString = recursiveStringBuilder(contentDoc, currentString);
        }
        return currentString;
    };
    return recursiveStringBuilder(doc, '');
}
exports.documentToBasicString = documentToBasicString;
/**
 * Build a rich text document out of a basic string
 */
function convertBasicStringToDocument(text) {
    // Extract URLs and convert to text with link marks
    const urlMatches = [...text.matchAll(MID_STRING_URL_RGX)].map((m) => m[0]);
    const splitTexts = text.split(MID_STRING_URL_RGX);
    const textNodes = [];
    for (const textPart of splitTexts) {
        // Build text node, if text part not empty
        if ((0, _lodash_1.trim)(textPart)) {
            textNodes.push({
                type: 'text',
                text: textPart
            });
        }
        // Get url node to append, if any remaining
        const url = urlMatches.shift();
        if (url) {
            textNodes.push({
                type: 'text',
                text: url,
                marks: [
                    {
                        attrs: {
                            href: url,
                            target: '_blank'
                        },
                        type: 'link'
                    }
                ]
            });
        }
    }
    return {
        type: 'doc',
        content: [
            {
                type: 'paragraph',
                content: textNodes
            }
        ]
    };
}
exports.convertBasicStringToDocument = convertBasicStringToDocument;
//# sourceMappingURL=index.js.map