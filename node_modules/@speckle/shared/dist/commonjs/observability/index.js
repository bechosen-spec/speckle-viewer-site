"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simpleRpmCounter = exports.extendLoggerComponent = exports.getLogger = void 0;
const pino_1 = require("pino");
const pinoClef_js_1 = require("./pinoClef.js");
let logger;
function getLogger(logLevel = 'info', pretty = false, mixin) {
    if (logger)
        return logger;
    const pinoOptions = {
        base: undefined,
        formatters: {
            level: (label, number) => 
            // for not pretty, we're providing clef levels
            pretty
                ? { level: label }
                : {
                    '@l': number in pinoClef_js_1.clefLevels
                        ? pinoClef_js_1.clefLevels[number]
                        : pinoClef_js_1.clefLevels[30]
                },
            log: (logObject) => (pretty ? logObject : (0, pinoClef_js_1.toClef)(logObject))
        },
        mixin,
        // when not pretty, to produce a clef format, we need the message to be the message template key
        messageKey: pretty ? 'msg' : '@mt',
        level: logLevel,
        // when not pretty, we need the time in the clef appropriate field, not from pino
        timestamp: pretty ? pino_1.pino.stdTimeFunctions.isoTime : false
    };
    if (pretty) {
        pinoOptions.transport = {
            target: '@speckle/shared/pinoPrettyTransport.cjs',
            options: {
                colorize: true,
                destination: 2,
                ignore: 'time',
                levelFirst: true,
                singleLine: true
            }
        };
    }
    logger = (0, pino_1.pino)(pinoOptions);
    return logger;
}
exports.getLogger = getLogger;
function extendLoggerComponent(otherChild, ...subComponent) {
    const otherChildBindings = otherChild.bindings();
    otherChildBindings.component = [otherChildBindings.component, ...subComponent]
        .filter(Boolean)
        .join('/');
    return otherChild.child(otherChildBindings);
}
exports.extendLoggerComponent = extendLoggerComponent;
/**
 * Very simple RPM counter to catch extreme spam scenarios (e.g. a ton of errors being thrown). It's not going
 * to always report accurately, but as long as hits are being registered consistently it should be accurate enough.
 */
function simpleRpmCounter() {
    const getTimestamp = () => new Date().getTime();
    let lastDateTimestamp = getTimestamp();
    let hits = 0;
    const validateHits = () => {
        const timestamp = getTimestamp();
        if (timestamp > lastDateTimestamp + 60 * 1000) {
            hits = 0;
            lastDateTimestamp = timestamp;
        }
    };
    return {
        hit: () => {
            validateHits();
            return ++hits;
        },
        get: () => {
            validateHits();
            return hits;
        }
    };
}
exports.simpleRpmCounter = simpleRpmCounter;
//# sourceMappingURL=index.js.map