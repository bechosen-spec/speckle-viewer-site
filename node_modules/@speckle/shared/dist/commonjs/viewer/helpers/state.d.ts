import type { MaybeNullOrUndefined, Nullable } from '../../core/helpers/utilityTypes.js';
import type { PartialDeep } from 'type-fest';
declare enum MeasurementType {
    PERPENDICULAR = 0,
    POINTTOPOINT = 1
}
interface MeasurementOptions {
    visible: boolean;
    type?: MeasurementType;
    vertexSnap?: boolean;
    units?: string;
    precision?: number;
}
/**
 * v1 -> v1.1
 * - ui.filters.propertyFilter.isApplied field added
 * - ui.spotlightUserId swapped for spotlightUserSessionId
 * v1.1 -> v1.2
 * - ui.diff added
 */
export declare const SERIALIZED_VIEWER_STATE_VERSION = 1.2;
export type SerializedViewerState = {
    projectId: string;
    sessionId: string;
    viewer: {
        metadata: {
            filteringState: Nullable<{
                passMin?: MaybeNullOrUndefined<number>;
                passMax?: MaybeNullOrUndefined<number>;
            }>;
        };
    };
    resources: {
        request: {
            resourceIdString: string;
            threadFilters: {
                includeArchived?: MaybeNullOrUndefined<boolean>;
                loadedVersionsOnly?: MaybeNullOrUndefined<boolean>;
            };
        };
    };
    ui: {
        threads: {
            openThread: {
                threadId: Nullable<string>;
                isTyping: boolean;
                newThreadEditor: boolean;
            };
        };
        diff: {
            command: Nullable<string>;
            time: number;
            mode: number;
        };
        spotlightUserSessionId: Nullable<string>;
        filters: {
            isolatedObjectIds: string[];
            hiddenObjectIds: string[];
            selectedObjectIds: string[];
            propertyFilter: {
                key: Nullable<string>;
                isApplied: boolean;
            };
        };
        camera: {
            position: number[];
            target: number[];
            isOrthoProjection: boolean;
            zoom: number;
        };
        sectionBox: Nullable<{
            min: number[];
            max: number[];
        }>;
        lightConfig: {
            intensity?: number;
            indirectLightIntensity?: number;
            elevation?: number;
            azimuth?: number;
        };
        explodeFactor: number;
        selection: Nullable<number[]>;
        measurement: {
            enabled: boolean;
            options: Nullable<MeasurementOptions>;
        };
    };
};
type UnformattedState = PartialDeep<SerializedViewerState>;
/**
 * Note: This only does superficial validation. To really ensure that all of the keys are there, even if prefilled with default values, make sure you invoke
 * formatSerializedViewerState() on the state afterwards
 */
export declare const isSerializedViewerState: (val: unknown) => val is SerializedViewerState;
/**
 * Formats SerializedViewerState by bringing it up to date with the structure of the latest version
 * and ensuring missing keys are initialized with default values
 */
export declare const formatSerializedViewerState: (state: UnformattedState) => SerializedViewerState;
export {};
//# sourceMappingURL=state.d.ts.map