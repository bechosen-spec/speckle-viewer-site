"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatResultsSchema = exports.isResultsSchema = exports.formatTriggerDefinitionSchema = exports.isTriggerDefinitionSchema = exports.isVersionCreatedTriggerDefinition = exports.REDACTED_VALUE = exports.RESULTS_SCHEMA_VERSION = exports.TRIGGER_DEFINITIONS_SCHEMA_VERSION = void 0;
const _lodash_1 = require("#lodash");
const index_js_1 = require("../errors/index.js");
exports.TRIGGER_DEFINITIONS_SCHEMA_VERSION = 1.0;
exports.RESULTS_SCHEMA_VERSION = 1.0;
exports.REDACTED_VALUE = '******';
const isVersionCreatedTriggerDefinition = (val) => {
    if (!val)
        return false;
    if (!(0, _lodash_1.isObjectLike)(val))
        return false;
    return (0, _lodash_1.get)(val, 'type') === 'VERSION_CREATED' && (0, _lodash_1.has)(val, 'modelId');
};
exports.isVersionCreatedTriggerDefinition = isVersionCreatedTriggerDefinition;
const isTriggerDefinitionSchema = (val) => {
    if (!val)
        return false;
    const keys = ['version', 'definitions'];
    if (!(0, _lodash_1.isObjectLike)(val))
        return false;
    const valKeys = Object.keys(val);
    if ((0, _lodash_1.intersection)(valKeys, keys).length !== keys.length)
        return false;
    return true;
};
exports.isTriggerDefinitionSchema = isTriggerDefinitionSchema;
const formatTriggerDefinitionSchema = (state) => {
    const throwInvalidError = (missingPath) => {
        throw new index_js_1.UnformattableTriggerDefinitionSchemaError('Required data missing from TriggerDefinitionsSchema: ' + missingPath);
    };
    if (!(0, exports.isTriggerDefinitionSchema)(state)) {
        throw new index_js_1.UnformattableTriggerDefinitionSchemaError('Invalid trigger definition schema');
    }
    const version = (0, _lodash_1.isNumber)(state.version) ? state.version : throwInvalidError('version');
    return {
        version,
        definitions: (state.definitions || throwInvalidError('definitions')).map((d) => {
            if (!(0, _lodash_1.isObjectLike)(d))
                throw new index_js_1.UnformattableTriggerDefinitionSchemaError('Invalid non-object trigger definition');
            switch (d.type || '') {
                case 'VERSION_CREATED':
                    return {
                        type: d.type,
                        modelId: d.modelId || throwInvalidError('definitions.modelId')
                    };
                default:
                    throw new index_js_1.UnformattableTriggerDefinitionSchemaError(`Unknown trigger definition type: ${d.type}`);
            }
        })
    };
};
exports.formatTriggerDefinitionSchema = formatTriggerDefinitionSchema;
const isResultsSchema = (val) => {
    if (!val)
        return false;
    const keys = ['version', 'values'];
    if (!(0, _lodash_1.isObjectLike)(val))
        return false;
    const valKeys = Object.keys(val);
    if ((0, _lodash_1.intersection)(valKeys, keys).length !== keys.length)
        return false;
    if (!(0, _lodash_1.isArray)((0, _lodash_1.get)(val, 'values.objectResults')))
        return false;
    if ((0, _lodash_1.get)(val, 'values.blobIds') && !(0, _lodash_1.isArray)((0, _lodash_1.get)(val, 'values.blobIds')))
        return false;
    return true;
};
exports.isResultsSchema = isResultsSchema;
const formatResultsSchema = (state) => {
    const throwInvalidError = (missingPath) => {
        throw new index_js_1.UnformattableResultsSchemaError('Required data missing from ResultsSchema: ' + missingPath);
    };
    if (!(0, exports.isResultsSchema)(state)) {
        throw new index_js_1.UnformattableResultsSchemaError('Invalid results schema');
    }
    const values = state.values || throwInvalidError('values');
    if (!(0, _lodash_1.isObjectLike)(values.objectResults)) {
        throw new index_js_1.UnformattableResultsSchemaError('Invalid objectResults type. It should be a record.');
    }
    const version = (0, _lodash_1.isNumber)(state.version) ? state.version : throwInvalidError('version');
    return {
        version,
        values: {
            objectResults: (values.objectResults || []).map((value, i) => {
                if (!(0, _lodash_1.isObjectLike)(value)) {
                    throw new index_js_1.UnformattableResultsSchemaError(`Invalid objectResults entry for index: ${i}. It should be a record.`);
                }
                return {
                    category: value.category || throwInvalidError(`values.[${i}].objectResults.category`),
                    level: value.level || throwInvalidError(`values.[${i}].objectResults.level`),
                    objectIds: value.objectIds ||
                        throwInvalidError(`values.[${i}].objectResults.objectIds`),
                    message: value.message || null,
                    metadata: value.metadata || null,
                    visualoverrides: value.visualoverrides || null
                };
            }),
            blobIds: values.blobIds || undefined
        }
    };
};
exports.formatResultsSchema = formatResultsSchema;
//# sourceMappingURL=types.js.map