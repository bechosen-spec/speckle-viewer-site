import type { MaybeAsync, NonNullableProperties, NullableKeysToOptional } from './utilityTypes.js';
export declare class TimeoutError extends Error {
}
export declare class WaitIntervalUntilCanceledError extends Error {
}
/**
 * Build promise that can be resolved/rejected manually outside of the promise's execution scope
 */
export declare const buildManualPromise: <T>() => {
    promise: Promise<T>;
    resolve: (value: T) => void;
    reject: (reason?: any) => void;
};
export declare const isNullOrUndefined: (val: unknown) => val is null | undefined;
export declare const wait: (ms: number) => Promise<unknown>;
export declare const waitIntervalUntil: (ms: number, predicate: () => boolean) => Promise<void> & {
    cancel: () => void;
};
/**
 * Not nullable type guard, useful in `.filter()` calls for proper TS typed
 * results
 */
export declare const isNonNullable: <V>(v: V) => v is NonNullable<V>;
/**
 * Make the promise throw after enough time has passed. Useful for implementing timeout functionality in various flows.
 */
export declare const timeoutAt: (ms: number, optionalMessage?: string) => Promise<never>;
/**
 * Invoke and return fn(), but retry it up to n times if it throws
 */
export declare const retry: <V = unknown>(fn: () => MaybeAsync<V>, n: number, delayMs?: number | ((attempt: number, error: Error) => number) | undefined) => Promise<V>;
/**
 * For quickly profiling a function
 */
export declare const profile: <V = unknown>(fn: () => MaybeAsync<V>, label?: string, extra?: unknown) => Promise<V>;
/**
 * For quickly profiling a sync function
 */
export declare const profileSync: <V = unknown>(fn: () => V, label?: string, extra?: unknown) => V;
export declare const removeNullOrUndefinedKeys: <T extends Record<string, unknown>>(obj: T) => NonNullableProperties<NullableKeysToOptional<T>>;
export declare const isArrayOf: <T>(arr: unknown, guard: (v: unknown) => v is T) => arr is T[];
export declare const waitForever: () => Promise<never>;
//# sourceMappingURL=utility.d.ts.map