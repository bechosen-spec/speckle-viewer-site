export declare const speckleDepthFrag = "\n#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#ifdef LINEAR_DEPTH\n    varying vec4 vViewPosition;\n\tuniform float near;\n\tuniform float far;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t// #include <alphatest_fragment>\n\t#ifdef USE_ALPHATEST\n\t\tif ( diffuseColor.a < alphaTest ) discard;\n\t\t/** This is a workaround for rejecting shadows for certain materials, since three.js gave me no choice*/\n\t\t#ifdef ALPHATEST_REJECTION\n\t\t\tif (alphaTest > 0. ) discard;\n\t\t#endif\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\t#ifdef LINEAR_DEPTH\n\t\t/** View z is negative moving away from the camera */\n\t\tgl_FragColor = packDepthToRGBA((vViewPosition.z + near) / (near - far));\n\t#else\n\t\tfloat fragCoordZ = (0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5);\n\t\t#if DEPTH_PACKING == 3200\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t\t#elif DEPTH_PACKING == 3201\n\t\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t\t#endif\n\t#endif\n}\n";
