export declare const speckleGhostVert = "\n#include <common>\n#ifdef USE_RTE\n    // The high component is stored as the default 'position' attribute buffer\n    attribute vec3 position_low;\n    uniform vec3 uViewer_high;\n    uniform vec3 uViewer_low;\n#endif\n\n#ifdef TRANSFORM_STORAGE\n    attribute float objIndex;\n\n    #if TRANSFORM_STORAGE == 0\n        #if __VERSION__ == 300\n            #define TRANSFORM_STRIDE 4\n        #else\n            #define TRANSFORM_STRIDE 4.\n        #endif\n        uniform sampler2D tTransforms;\n        uniform float objCount;\n    #elif TRANSFORM_STORAGE == 1\n        uniform mat4 uTransforms[OBJ_COUNT];\n    #endif\n#endif\n\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef TRANSFORM_STORAGE\n    void objectTransform(out vec4 quaternion, out vec4 pivotLow, out vec4 pivotHigh, out vec4 translation, out vec4 scale){\n        #if TRANSFORM_STORAGE == 0\n            #if __VERSION__ == 300\n                ivec2 uv = ivec2(int(objIndex) * TRANSFORM_STRIDE, 0); \n                vec4 v0 = texelFetch( tTransforms, uv, 0 );\n                vec4 v1 = texelFetch( tTransforms, uv + ivec2(1, 0), 0);\n                vec4 v2 = texelFetch( tTransforms, uv + ivec2(2, 0), 0);\n                vec4 v3 = texelFetch( tTransforms, uv + ivec2(3, 0), 0);\n                quaternion = v0;\n                pivotLow = vec4(v1.xyz, 1.);\n                pivotHigh = vec4(v2.xyz, 1.);\n                translation = vec4(v3.xyz, 1.);\n                scale = vec4(v1.w, v2.w, v3.w, 1.);\n            #elif\n                float size = objCount * TRANSFORM_STRIDE;\n                vec2 cUv = vec2(0.5/size, 0.5);\n                vec2 dUv = vec2(1./size, 0.);\n                \n                vec2 uv = vec2((objIndex * TRANSFORM_STRIDE)/size + cUv.x, cUv.y);\n                vec4 v0 = texture2D( tTransforms, uv);\n                vec4 v1 = texture2D( tTransforms, uv + dUv);\n                vec4 v2 = texture2D( tTransforms, uv + 2. * dUv);\n                vec4 v3 = texture2D( tTransforms, uv + 3. * dUv);\n                quaternion = v0;\n                pivotLow = vec4(v1.xyz, 1.);\n                pivotHigh = vec4(v2.xyz, 1.);\n                translation = vec4(v3.xyz, 1.);\n                scale = vec4(v1.w, v2.w, v3.w, 1.);\n            #endif\n        #elif TRANSFORM_STORAGE == 1\n            mat4 tMatrix = uTransforms[int(objIndex)];\n            quaternion = tMatrix[0];\n            pivotLow = vec4(tMatrix[1].xyz, 1.);\n            pivotHigh = vec4(tMatrix[2].xyz, 1.);\n            translation = vec4(tMatrix[3].xyz, 1.);\n            scale = vec4(tMatrix[1][3], tMatrix[2][3], tMatrix[3][3], 1.);\n        #endif\n    }\n\n    vec3 rotate_vertex_position(vec3 position, vec4 quat)\n    { \n        return position + 2.0 * cross(quat.xyz, cross(quat.xyz, position) + quat.w * position);\n    }\n#endif\n\n#ifdef USE_RTE\n    vec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){\n        /* \n        Vector calculation for the high and low differences works on everything \n        *BESIDES* Apple Silicon (or whatever they call it) GPUs\n\n        It would seem that when this code gets compiled, vector types get a lower precision(?)\n        which completely brakes the 2 float -> double reconstructio. Doing it separately for each \n        vector component using floats works fine.\n        */\n        vec3 highDifference;\n        vec3 lowDifference;\n        float t1 = position_low.x - relativeTo_low.x;\n        float e = t1 - position_low.x;\n        float t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;\n        highDifference.x = t1 + t2;\n        lowDifference.x = t2 - (highDifference.x - t1);\n\n        t1 = position_low.y - relativeTo_low.y;\n        e = t1 - position_low.y;\n        t2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;\n        highDifference.y = t1 + t2;\n        lowDifference.y = t2 - (highDifference.y - t1);\n\n        t1 = position_low.z - relativeTo_low.z;\n        e = t1 - position_low.z;\n        t2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;\n        highDifference.z = t1 + t2;\n        lowDifference.z = t2 - (highDifference.z - t1);\n\n        vec3 position = highDifference.xyz + lowDifference.xyz;\n        return vec4(position, 1.);\n    }\n\n    vec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){\n        /* \n        Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl \n        Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy \n        */\n        vec3 t1 = position_low.xyz - relativeTo_low;\n        vec3 e = t1 - position_low.xyz;\n        vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;\n        vec3 highDifference = t1 + t2;\n        vec3 lowDifference = t2 - (highDifference - t1);\n        \n        vec3 position = highDifference.xyz + lowDifference.xyz;\n        return vec4(position, 1.);\n    }\n#endif\n\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t// #include <project_vertex> COMMENTED CHUNK\n    #ifdef TRANSFORM_STORAGE\n        vec4 tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale;\n        objectTransform(tQuaternion, tPivotLow, tPivotHigh, tTranslation, tScale);\n    #endif\n    #ifdef USE_RTE\n        vec4 position_lowT = vec4(position_low, 1.);\n        vec4 position_highT = vec4(position, 1.);\n        const vec3 ZERO3 = vec3(0., 0., 0.);\n\n        vec4 rteLocalPosition = computeRelativePositionSeparate(position_lowT.xyz, position_highT.xyz, uViewer_low, uViewer_high);\n        #ifdef TRANSFORM_STORAGE\n            vec4 rtePivot = computeRelativePositionSeparate(tPivotLow.xyz, tPivotHigh.xyz, uViewer_low, uViewer_high);\n            rteLocalPosition.xyz = rotate_vertex_position((rteLocalPosition - rtePivot).xyz, tQuaternion) * tScale.xyz + rtePivot.xyz + tTranslation.xyz;\n        #endif\n        #ifdef USE_INSTANCING\n            vec4 instancePivot = computeRelativePositionSeparate(ZERO3, ZERO3, uViewer_low, uViewer_high);\n            rteLocalPosition.xyz = (mat3(instanceMatrix) * (rteLocalPosition - instancePivot).xyz) + instancePivot.xyz + instanceMatrix[3].xyz;\n        #endif\n    #endif\n\n    #ifdef USE_RTE\n        vec4 mvPosition = rteLocalPosition;\n    #else\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        #ifdef USE_INSTANCING\n            mvPosition = instanceMatrix * mvPosition;\n        #endif\n    #endif\n    \n    mvPosition = modelViewMatrix * mvPosition;\n\n    gl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";
