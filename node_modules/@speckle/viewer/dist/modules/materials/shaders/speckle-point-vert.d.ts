export declare const specklePointVert = "\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_RTE\n    // The high component is stored as the default 'position' attribute buffer\n    attribute vec3 position_low;\n    uniform vec3 uViewer_high;\n    uniform vec3 uViewer_low;\n#endif\n\nvec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){\n    /* \n    Vector calculation for the high and low differences works on everything \n    *BESIDES* Apple Silicon (or whatever they call it) GPUs\n\n    It would seem that when this code gets compiled, vector types get a lower precision(?)\n    which completely brakes the 2 float -> double reconstructio. Doing it separately for each \n    vector component using floats works fine.\n    */\n    vec3 highDifference;\n    vec3 lowDifference;\n    float t1 = position_low.x - relativeTo_low.x;\n    float e = t1 - position_low.x;\n    float t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;\n    highDifference.x = t1 + t2;\n    lowDifference.x = t2 - (highDifference.x - t1);\n\n    t1 = position_low.y - relativeTo_low.y;\n    e = t1 - position_low.y;\n    t2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;\n    highDifference.y = t1 + t2;\n    lowDifference.y = t2 - (highDifference.y - t1);\n\n    t1 = position_low.z - relativeTo_low.z;\n    e = t1 - position_low.z;\n    t2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;\n    highDifference.z = t1 + t2;\n    lowDifference.z = t2 - (highDifference.z - t1);\n\n    vec3 position = highDifference.xyz + lowDifference.xyz;\n    return vec4(position, 1.);\n}\n\nvec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){\n    /* \n    Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl \n    Note here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy \n    */\n    vec3 t1 = position_low.xyz - relativeTo_low;\n    vec3 e = t1 - position_low.xyz;\n    vec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;\n    vec3 highDifference = t1 + t2;\n    vec3 lowDifference = t2 - (highDifference - t1);\n    \n    vec3 position = highDifference.xyz + lowDifference.xyz;\n    return vec4(position, 1.);\n}\n\n#ifdef USE_GRADIENT_RAMP\n    attribute float gradientIndex;\n    varying float vGradientIndex;\n#endif\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t// #include <project_vertex> COMMENTED CHUNK\n\t#ifdef USE_RTE\n        vec4 mvPosition = computeRelativePositionSeparate(position_low.xyz, position.xyz, uViewer_low, uViewer_high);\n    #else\n        vec4 mvPosition = vec4( transformed, 1.0 );\n    #endif\n    \n    #ifdef USE_INSTANCING\n\n        mvPosition = instanceMatrix * mvPosition;\n\n    #endif\n    mvPosition = modelViewMatrix * mvPosition;\n\n    #ifdef USE_GRADIENT_RAMP\n        vGradientIndex = gradientIndex;\n    #endif\n\n    gl_Position = projectionMatrix * mvPosition;\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n";
