export declare const speckleLineVert = "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\t\tuniform float pixelThreshold;\n\n\t\tvarying float vAlpha;\n\n\t\t#define SEARCH_STEPS 10\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec4 instanceColorStart;\n\t\tattribute vec4 instanceColorEnd;\n\t\t// varying vec3 debugColor;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\t\t\tvarying float correctedLineWidth;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n        #ifdef USE_RTE\n\t\t\tattribute vec3 instanceStartLow;\n\t\t\tattribute vec3 instanceEndLow;\n            uniform vec3 uViewer_high;\n            uniform vec3 uViewer_low;\n        #endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tfloat screenSpaceDistance(vec4 p0, vec4 p1) {\n\t\t\tp0 = projectionMatrix * p0;\n\t\t\tp0 /= p0.w;\n\t\t\tp1 = projectionMatrix * p1;\n\t\t\tp1 /= p1.w;\n\t\t\treturn length(p1.xy - p0.xy);\n\t\t}\n\n\t\tvec4 computeRelativePositionSeparate(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){\n\t\t\t/* \n\t\t\tVector calculation for the high and low differences works on everything \n\t\t\t*BESIDES* Apple Silicon (or whatever they call it) GPUs\n\n\t\t\tIt would seem that when this code gets compiled, vector types get a lower precision(?)\n\t\t\twhich completely brakes the 2 float -> double reconstructio. Doing it separately for each \n\t\t\tvector component using floats works fine.\n\t\t\t*/\n\t\t\tvec3 highDifference;\n\t\t\tvec3 lowDifference;\n\t\t\tfloat t1 = position_low.x - relativeTo_low.x;\n\t\t\tfloat e = t1 - position_low.x;\n\t\t\tfloat t2 = ((-relativeTo_low.x - e) + (position_low.x - (t1 - e))) + position_high.x - relativeTo_high.x;\n\t\t\thighDifference.x = t1 + t2;\n\t\t\tlowDifference.x = t2 - (highDifference.x - t1);\n\n\t\t\tt1 = position_low.y - relativeTo_low.y;\n\t\t\te = t1 - position_low.y;\n\t\t\tt2 = ((-relativeTo_low.y - e) + (position_low.y - (t1 - e))) + position_high.y - relativeTo_high.y;\n\t\t\thighDifference.y = t1 + t2;\n\t\t\tlowDifference.y = t2 - (highDifference.y - t1);\n\n\t\t\tt1 = position_low.z - relativeTo_low.z;\n\t\t\te = t1 - position_low.z;\n\t\t\tt2 = ((-relativeTo_low.z - e) + (position_low.z - (t1 - e))) + position_high.z - relativeTo_high.z;\n\t\t\thighDifference.z = t1 + t2;\n\t\t\tlowDifference.z = t2 - (highDifference.z - t1);\n\n\t\t\tvec3 position = highDifference.xyz + lowDifference.xyz;\n\t\t\treturn vec4(position, 1.);\n\t\t}\n\n\t\tvec4 computeRelativePosition(in vec3 position_low, in vec3 position_high, in vec3 relativeTo_low, in vec3 relativeTo_high){\n\t\t\t/* \n\t\t\tSource https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl \n\t\t\tNote here, we're storing the high part of the position encoding inside three's default 'position' attribute buffer so we avoid redundancy \n\t\t\t*/\n\t\t\tvec3 t1 = position_low.xyz - relativeTo_low;\n\t\t\tvec3 e = t1 - position_low.xyz;\n\t\t\tvec3 t2 = ((-relativeTo_low - e) + (position_low.xyz - (t1 - e))) + position_high.xyz - relativeTo_high;\n\t\t\tvec3 highDifference = t1 + t2;\n\t\t\tvec3 lowDifference = t2 - (highDifference - t1);\n\t\t\t\n\t\t\tvec3 position = highDifference.xyz + lowDifference.xyz;\n\t\t\treturn vec4(position, 1.);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tif(instanceColorStart.w == 0.) {\n\t\t\t\tgl_Position = vec4(0.);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tvAlpha = instanceColorStart.w;\n\n            vec3 computedPosition = position;\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( computedPosition.y < 0.5 ) ? instanceColorStart.xyz : instanceColorEnd.xyz;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( computedPosition.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n            #ifdef USE_RTE\n\t\t\t/** Source https://github.com/virtualglobebook/OpenGlobe/blob/master/Source/Examples/Chapter05/Jitter/GPURelativeToEyeDSFUN90/Shaders/VS.glsl */\n\t\t\t\t// vec3 t1 = instanceStartLow.xyz - uViewer_low;\n\t\t\t\t// vec3 e = t1 - instanceStartLow.xyz;\n\t\t\t\t// vec3 t2 = ((-uViewer_low - e) + (instanceStartLow.xyz - (t1 - e))) + instanceStart.xyz - uViewer_high;\n\t\t\t\t// vec3 highDifference = t1 + t2;\n\t\t\t\t// vec3 lowDifference = t2 - (highDifference - t1);\n\t\t\t\t// vec4 start = modelViewMatrix * vec4(highDifference.xyz + lowDifference.xyz , 1.);\n\t\t\t\tvec4 start = modelViewMatrix * computeRelativePositionSeparate(instanceStartLow.xyz, instanceStart.xyz, uViewer_low, uViewer_high);\n\t\t\t\t\n\t\t\t\t// t1 = instanceEndLow.xyz - uViewer_low;\n\t\t\t\t// e = t1 - instanceEndLow.xyz;\n\t\t\t\t// t2 = ((-uViewer_low - e) + (instanceEndLow.xyz - (t1 - e))) + instanceEnd.xyz - uViewer_high;\n\t\t\t\t// highDifference = t1 + t2;\n\t\t\t\t// lowDifference = t2 - (highDifference - t1);\n\t\t\t\t// vec4 end = modelViewMatrix * vec4(highDifference.xyz + lowDifference.xyz , 1.);\n\t\t\t\tvec4 end = modelViewMatrix * computeRelativePositionSeparate(instanceEndLow.xyz, instanceEnd.xyz, uViewer_low, uViewer_high);\n            #else\n                vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n                vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n            #endif\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// get the offset direction as perpendicular to the view vector\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 offset;\n\t\t\t\tif ( computedPosition.y < 0.5 ) {\n\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\n\n\t\t\t\t}\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( computedPosition.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\n\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\n\t\t\t\t\toffset.z += 0.5;\n\n\t\t\t\t#endif\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( computedPosition.y > 1.0 || computedPosition.y < 0.0 ) {\n\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\n\n\t\t\t\t}\n\n\t\t\t\t// debugColor = vec3(0., 0., 1.);\n\t\t\t\tcorrectedLineWidth = linewidth;\n\t\t\t\tvec3 cOffset = offset;\n\t\t\t\t\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth * 0.5;\n\n\t\t\t\t// set the world position\n\t\t\t\tworldPos = ( computedPosition.y < 0.5 ) ? start : end;\n\n\t\t\t\t/*\n\t\t\t\tNot great, not terrible\n\t\t\t\t*/\n\t\t\t\tfloat pixelSize = length(vec2(pixelThreshold/resolution.x + pixelThreshold/resolution.y));\n\t\t\t\tfloat offsetStep = linewidth;\n\t\t\t\tfloat d = screenSpaceDistance(worldPos, worldPos + vec4(cOffset * offsetStep, 0.));\n\t\t\t\t/* We're trying to start off with a step closer to the initial difference between SS distance and the pixel size we want\n\t\t\t\t*/\n\t\t\t\t// offsetStep += pixelSize - d;\n\t\t\t\tvec3 move = offset;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < SEARCH_STEPS; i++){\n\t\t\t\t\tmove = cOffset * offsetStep;\n\t\t\t\t\td = screenSpaceDistance(worldPos, worldPos + vec4(move, 0.));\n\t\t\t\t\tif(d > pixelSize) {\n\t\t\t\t\t\tcorrectedLineWidth = offsetStep;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\toffsetStep += offsetStep;\n\t\t\t\t}\n\n\t\t\t\tworldPos.xyz += move;\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( computedPosition.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( computedPosition.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( computedPosition.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( computedPosition.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( computedPosition.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( computedPosition.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t";
