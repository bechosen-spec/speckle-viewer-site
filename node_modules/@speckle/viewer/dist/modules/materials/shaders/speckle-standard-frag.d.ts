export declare const speckleStandardFrag = "\n#define STANDARD\n\n#ifdef PHYSICAL\n    #define IOR\n    #define SPECULAR\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef IOR\n    uniform float ior;\n#endif\n\n#ifdef SPECULAR\n    uniform float specularIntensity;\n    uniform vec3 specularColor;\n\n    #ifdef USE_SPECULARINTENSITYMAP\n        uniform sampler2D specularIntensityMap;\n    #endif\n\n    #ifdef USE_SPECULARCOLORMAP\n        uniform sampler2D specularColorMap;\n    #endif\n#endif\n\n#ifdef USE_CLEARCOAT\n    uniform float clearcoat;\n    uniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n    uniform vec3 sheenColor;\n    uniform float sheenRoughness;\n\n    #ifdef USE_SHEENCOLORMAP\n        uniform sampler2D sheenColorMap;\n    #endif\n\n    #ifdef USE_SHEENROUGHNESSMAP\n        uniform sampler2D sheenRoughnessMap;\n    #endif\n#endif\n\nvarying vec3 vViewPosition;\n/** We're disabling color grading for now until we want to properly offer it to the users */\n//#define CUSTOM_TONEMAPPING \n\n#ifdef CUSTOM_TONEMAPPING\n\n\tuniform float contrast;\n\tuniform float saturation;\n\tuniform float whitescale;\n\tvec3 EvalLogContrastFunc(vec3 col, float eps, float logMidpoint, float contrastFactor)\n\t{\n\t\tvec3 x = max(vec3(0.), col);\n\t\tvec3 logX = log2(x+vec3(eps));\n\t\tvec3 adjX = vec3(logMidpoint) + (logX - vec3(logMidpoint)) * contrastFactor;\n\t\tvec3 ret = max(vec3(0.0), exp2(adjX) - vec3(eps));\n\t\treturn ret;\n\t}\n\n\tvec3 evalSaturation(vec3 rgbVal, float saturationFactor){\n\t\tvec3 lumaWeights = vec3(.25,.50,.25);\n\t\tvec3 grey = vec3(dot(lumaWeights,rgbVal));\n\t\treturn grey + saturationFactor*(rgbVal-grey);\n\t}\n\n\tvec3 evalExposure(vec3 rgbVal, float exposureFactor){\n\t\treturn rgbVal * exp2(exposureFactor);\n\t}\n\n\tvec3 filmicTonemap(vec3 x) {\n\t\tfloat A = 0.15;\n\t\tfloat B = 0.50;\n\t\tfloat C = 0.10;\n\t\tfloat D = 0.20;\n\t\tfloat E = 0.02;\n\t\tfloat F = 0.30;\n\t\tfloat W = 11.2;\n\t\treturn ((x*(A*x+C*B)+D*E) / (x*(A*x+B)+D*F))- E / F;\n\t}\n\n\n\tvec3 applyFilmicToneMap( vec3 color) \n\t{\n\t\tcolor = 2.0 * filmicTonemap( color);\n\t\tvec3 whiteScale = 1.0 / filmicTonemap(vec3(11.2));\n\t\tcolor *= whiteScale;\n\t\treturn color;\n\t}\n\n\tvec3 postProcess(in vec3 _color, float exposureFactor, float contrastFactor, float saturationFactor){\n\t\tvec3 color = _color;\n\n\t\t// color.rgb *= exposureFactor;\n\t\tcolor.rgb = evalSaturation(color.rgb, saturationFactor);\n\t\tcolor = EvalLogContrastFunc(color, 0.0001, 0.18, contrastFactor);\n\t\tcolor.rgb = ACESFilmicToneMapping( color );//applyFilmicToneMap(color.rgb);\n\t\treturn color;\n\t}\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n\n    #include <logdepthbuf_fragment>\n    #include <map_fragment>\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <roughnessmap_fragment>\n    #include <metalnessmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    #include <clearcoat_normal_fragment_begin>\n    #include <clearcoat_normal_fragment_maps>\n    #include <emissivemap_fragment>\n\n    // accumulation\n    #include <lights_physical_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n\n    // modulation\n    #include <aomap_fragment>\n\n    vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n    vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n    #include <transmission_fragment>\n\n    vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n    #ifdef USE_SHEEN\n\n        // Sheen energy compensation approximation calculation can be found at the end of\n        // https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\n        float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\n        outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\n    #endif\n\n    #ifdef USE_CLEARCOAT\n\n        float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n        vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\n        outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\n    #endif\n\n    #include <output_fragment>\n    // #include <tonemapping_fragment> // COMMENTED OUT\n    #ifdef TONE_MAPPING\n\t\t#ifdef CUSTOM_TONEMAPPING\n\t\t\tgl_FragColor.rgb = postProcess(gl_FragColor.rgb, toneMappingExposure, contrast, saturation);\n\t\t#else\n\t\t\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\t\t#endif\n\t#endif\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n\n}\n";
