import TreeModel, { type Model } from 'tree-model';
import { NodeRenderView } from './NodeRenderView.js';
import { RenderTree } from './RenderTree.js';
export type TreeNode = TreeModel.Node<NodeData>;
export type SearchPredicate = (node: TreeNode) => boolean;
export interface NodeData {
    id: string;
    raw: {
        [prop: string]: any;
    };
    children: TreeNode[];
    atomic: boolean;
    nestedNodes?: TreeNode[];
    subtreeId?: number;
    renderView?: NodeRenderView | null;
    instanced?: boolean;
}
export declare class WorldTree {
    private renderTreeInstances;
    private nodeMaps;
    private readonly supressWarnings;
    static readonly ROOT_ID = "ROOT";
    private subtreeId;
    constructor();
    /** The root render tree will always be non-null because it will always contain the root */
    getRenderTree(): RenderTree;
    getRenderTree(subtreeId: string): RenderTree | null;
    private tree;
    _root: TreeNode;
    get root(): TreeNode;
    private get nextSubtreeId();
    get nodeCount(): number;
    isRoot(node: TreeNode): boolean;
    isSubtreeRoot(node: TreeNode): boolean;
    parse(model: Model<NodeData>): TreeNode;
    addSubtree(node: TreeNode): void;
    addNode(node: TreeNode, parent: TreeNode | null): void;
    removeNode(node: TreeNode, removeChildren: boolean): void;
    findAll(predicate: SearchPredicate, node?: TreeNode): Array<TreeNode>;
    findId(id: string, subtreeId?: number): TreeNode[] | null;
    /** TODO: Would rather not have this */
    findSubtree(id: string): TreeNode | null;
    getAncestors(node: TreeNode): Array<TreeNode>;
    getInstances(subtreeId: string): {
        [id: string]: Record<string, TreeNode>;
    };
    /** TO DO: We might want to add boolean as return type here too */
    walk(predicate: SearchPredicate, node?: TreeNode): void;
    walkAsync(predicate: SearchPredicate, node?: TreeNode): Promise<boolean>;
    purge(subtreeId?: string): void;
}
