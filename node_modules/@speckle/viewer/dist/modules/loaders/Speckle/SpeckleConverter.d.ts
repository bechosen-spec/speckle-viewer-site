import { type TreeNode, WorldTree } from '../../tree/WorldTree.js';
import { type SpeckleObject } from '../../../index.js';
import type ObjectLoader from '@speckle/objectloader';
export type ConverterResultDelegate = () => Promise<void>;
export type SpeckleConverterNodeDelegate = ((object: SpeckleObject, node: TreeNode) => Promise<void>) | null;
/**
 * Utility class providing some top level conversion methods.
 * Warning: HIC SVNT DRACONES.
 */
export default class SpeckleConverter {
    private objectLoader;
    private activePromises;
    private maxChildrenPromises;
    private spoofIDs;
    private tree;
    private typeLookupTable;
    private instanceDefinitionLookupTable;
    private instancedObjectsLookupTable;
    private instanceProxies;
    private renderMaterialMap;
    private instanceCounter;
    private readonly NodeConverterMapping;
    private readonly IgnoreNodes;
    constructor(objectLoader: ObjectLoader, tree: WorldTree);
    /**
     * If the object is convertible (there is a direct conversion routine), it will invoke the callback with the conversion result.
     * If the object is not convertible, it will recursively iterate through it (arrays & objects) and invoke the callback on any positive conversion result.
     * @param  {[type]}   obj      [description]
     * @param  {Function} callback [description]
     * @return {[type]}            [description]
     */
    traverse(objectURL: string, obj: SpeckleObject, callback: ConverterResultDelegate, node?: TreeNode | null): Promise<void>;
    private getNodeId;
    /**
     * Takes an array composed of chunked references and dechunks it.
     * @param  {[type]} arr [description]
     * @return {[type]}     [description]
     */
    private dechunk;
    /**
     * Resolves an object reference by waiting for the loader to load it up.
     * @param  {[type]} obj [description]
     * @return {[type]}     [description]
     */
    private resolveReference;
    /**
     * Gets the speckle type of an object in various scenarios.
     * @param  {[type]} obj [description]
     * @return {[type]}     [description]
     */
    private getSpeckleType;
    private getSpeckleTypeChain;
    private directNodeConverterExists;
    private convertToNode;
    private getDisplayValue;
    private getElementsValue;
    private getBlockDefinition;
    private getBlockDefinitionGeometry;
    /** We're wasting a few milis here, but it is what it is */
    private getCompoundId;
    private getEmptyTransformData;
    /**
     *
      NODES
     */
    private View3DToNode;
    /** This is only used for Blocks to search for convertible objects, without using the main 'traverse' function
     *  It's only looking for 'elements' and 'displayValues'
     *  I think it can be used for RevitInstances as well to replace it's current lookup, but I'm afraid to do it
     */
    private displayableLookup;
    private parseInstanceDefinitionGeometry;
    private parseInstanceElement;
    private BlockInstanceToNode;
    private RevitInstanceToNode;
    private InstanceDefinitionProxyToNode;
    private InstanceProxyToNode;
    private RenderMaterialProxyToNode;
    private getInstanceProxyDefinitionId;
    private getInstanceProxyTransform;
    private getInstanceProxyDefinitionObjects;
    private createTransformNode;
    private ConvertInstanceProxyToNode;
    convertInstances(): Promise<void>;
    applyMaterials(): Promise<void>;
    private PointcloudToNode;
    private BrepToNode;
    private MeshToNode;
    private TextToNode;
    private DimensionToNode;
    private PointToNode;
    private LineToNode;
    private PolylineToNode;
    private BoxToNode;
    private PolycurveToNode;
    private CurveToNode;
    private CircleToNode;
    private ArcToNode;
    private EllipseToNode;
}
