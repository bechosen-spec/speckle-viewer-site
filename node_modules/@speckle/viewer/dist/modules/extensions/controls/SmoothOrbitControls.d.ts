import { Spherical, Vector3, PerspectiveCamera, Sphere, OrthographicCamera, Quaternion, Scene } from 'three';
import { World } from '../../World.js';
import { SpeckleControls } from './SpeckleControls.js';
import { Intersections } from '../../Intersections.js';
export type TouchMode = null | ((dx: number, dy: number) => void);
export type TouchAction = 'pan-y' | 'pan-x' | 'none';
export interface Pointer {
    clientX: number;
    clientY: number;
    id: number;
}
export interface SmoothOrbitControlsOptions {
    enableOrbit?: boolean;
    enableZoom?: boolean;
    enablePan?: boolean;
    orbitSensitivity?: number;
    zoomSensitivity?: number;
    panSensitivity?: number;
    inputSensitivity?: number;
    minimumRadius?: number;
    maximumRadius?: number;
    minimumPolarAngle?: number;
    maximumPolarAngle?: number;
    minimumAzimuthalAngle?: number;
    maximumAzimuthalAngle?: number;
    minimumFieldOfView?: number;
    maximumFieldOfView?: number;
    touchAction?: TouchAction;
    infiniteZoom?: boolean;
    zoomToCursor?: boolean;
    damperDecay?: number;
}
export declare enum PointerChangeEvent {
    PointerChangeStart = "pointer-change-start",
    PointerChangeEnd = "pointer-change-end"
}
/**
 * SmoothControls is a Three.js helper for adding delightful pointer and
 * keyboard-based input to a staged Three.js scene. Its API is very similar to
 * OrbitControls, but it offers more opinionated (subjectively more delightful)
 * defaults, easy extensibility and subjectively better out-of-the-box keyboard
 * support.
 *
 * One important change compared to OrbitControls is that the `update` method
 * of SmoothControls must be invoked on every frame, otherwise the controls
 * will not have an effect.
 *
 * Another notable difference compared to OrbitControls is that SmoothControls
 * does not currently support panning (but probably will in a future revision).
 *
 * Like OrbitControls, SmoothControls assumes that the orientation of the camera
 * has been set in terms of position, rotation and scale, so it is important to
 * ensure that the camera's matrixWorld is in sync before using SmoothControls.
 */
export declare class SmoothOrbitControls extends SpeckleControls {
    private _enabled;
    private _options;
    private isUserPointing;
    enablePan: boolean;
    enableTap: boolean;
    private panProjection;
    private panPerPixel;
    spherical: Spherical;
    private goalSpherical;
    private origin;
    private goalOrigin;
    private targetDamperX;
    private targetDamperY;
    private targetDamperZ;
    private thetaDamper;
    private phiDamper;
    private radiusDamper;
    private logFov;
    private goalLogFov;
    private fovDamper;
    private touchMode;
    private pointers;
    private startPointerPosition;
    private lastSeparation;
    private touchDecided;
    private zoomControlCoord;
    private _targetCamera;
    private _container;
    private _lastTick;
    private _basisTransform;
    private _basisTransformInv;
    private _radiusDelta;
    private scene;
    private world;
    private intersections;
    get enabled(): boolean;
    set enabled(value: boolean);
    get up(): Vector3;
    set up(value: Vector3);
    constructor(camera: PerspectiveCamera | OrthographicCamera, container: HTMLElement, world: World, scene: Scene, intersections: Intersections, options: Required<SmoothOrbitControlsOptions>);
    /**
     * The options that are currently configured for the controls instance.
     */
    get options(): Required<SmoothOrbitControlsOptions>;
    set options(value: SmoothOrbitControlsOptions);
    set targetCamera(value: PerspectiveCamera | OrthographicCamera);
    /** The input position and target will be in a basis with (0,1,0) as up */
    fromPositionAndTarget(position: Vector3, target: Vector3): void;
    /**
     * Move the camera instantly instead of accelerating toward the goal
     * parameters.
     */
    jumpToGoal(): void;
    fitToSphere(sphere: Sphere): void;
    /**
     * Gets the current goal position
     */
    getPosition(): Vector3;
    /**
     * Gets the point in model coordinates the model should orbit/pivot around.
     */
    getTarget(): Vector3;
    isStationary(): boolean;
    /**
     * Configure the _options of the controls. Configured _options will be
     * merged with whatever _options have already been configured for this
     * controls instance.
     */
    protected applyOptions(_options: SmoothOrbitControlsOptions): void;
    /** Computes min/max radius values based on the current world size */
    protected computeMinMaxRadius(): void;
    /**
     * Set the absolute orbital goal of the camera. The change will be
     * applied over a number of frames depending on configured acceleration and
     * dampening _options.
     *
     * Returns true if invoking the method will result in the camera changing
     * position and/or rotation, otherwise false.
     */
    setOrbit(goalTheta?: number, goalPhi?: number, goalRadius?: number): boolean;
    /**
     * Subset of setOrbit() above, which only sets the camera's radius.
     */
    setRadius(radius: number): void;
    /**
     * Sets the goal field of view for the camera
     */
    setFieldOfView(fov: number): void;
    /**
     * Sets the smoothing decay time.
     */
    setDamperDecayTime(decayMilliseconds: number): void;
    /**
     * Sets the point in model coordinates the object should orbit/pivot around.
     */
    setTarget(x: number, y: number, z: number): void;
    /**
     * Adjust the orbital position of the camera relative to its current orbital
     * position. Does not let the theta goal get more than pi ahead of the current
     * theta, which ensures interpolation continues in the direction of the delta.
     * The deltaZoom parameter adjusts both the field of view and the orbit radius
     * such that they progress across their allowed ranges in sync.
     */
    adjustOrbit(deltaTheta: number, deltaPhi: number, deltaZoom: number): void;
    /**
     * Update controls. In most cases, this will result in the camera
     * interpolating its position and rotation until it lines up with the
     * designated goal orbital position. Returns false if the camera did not move.
     *
     * Time and delta are measured in milliseconds.
     */
    update(delta?: number): boolean;
    protected moveCamera(): void;
    /** Three.js Spherical assumes (0, 1, 0) as up... */
    protected positionFromSpherical(spherical: Spherical, origin?: Vector3): Vector3;
    /** Three.js Spherical assumes (0, 1, 0) as up... */
    protected quaternionFromSpherical(spherical: Spherical): Quaternion;
    protected userAdjustOrbit(deltaTheta: number, deltaPhi: number, deltaZoom: number): void;
    protected enableInteraction(): void;
    protected disableInteraction(): void;
    protected wrapAngle(radians: number): number;
    protected pixelLengthToSphericalAngle(pixelLength: number): number;
    protected twoTouchDistance(touchOne: Pointer, touchTwo: Pointer): number;
    protected touchModeZoom: TouchMode;
    protected disableScroll: (event: TouchEvent) => void;
    protected touchModeRotate: TouchMode;
    protected handleSinglePointerMove(dx: number, dy: number): void;
    protected initializePan(): void;
    protected movePan(dx: number, dy: number): void;
    protected onPointerDown: (event: PointerEvent) => void;
    protected onPointerMove: (event: PointerEvent) => void;
    protected onPointerUp: (event: PointerEvent) => void;
    protected onTouchChange(event: PointerEvent): void;
    protected onMouseDown(event: MouseEvent): void;
    protected onWheel: (event: WheelEvent) => void;
    protected onContext: (event: MouseEvent) => void;
    dispose(): void;
}
