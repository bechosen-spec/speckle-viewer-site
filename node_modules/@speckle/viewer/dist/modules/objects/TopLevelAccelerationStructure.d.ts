import { Box3, Material, Ray, Side, Vector3 } from 'three';
import { MeshBVHVisualizer } from 'three-mesh-bvh';
import { BatchObject } from '../batching/BatchObject.js';
import { HitPointInfo } from 'three-mesh-bvh';
import type { ExtendedMeshIntersection, ExtendedShapeCastCallbacks } from './SpeckleRaycaster.js';
import { AccelerationStructure } from './AccelerationStructure.js';
/**
 *
  _____                            _              _
 |_   _|                          | |            | |
   | |  _ __ ___  _ __   ___  _ __| |_ __ _ _ __ | |_
   | | | '_ ` _ \| '_ \ / _ \| '__| __/ _` | '_ \| __|
  _| |_| | | | | | |_) | (_) | |  | || (_| | | | | |_
 |_____|_| |_| |_| .__/ \___/|_|   \__\__,_|_| |_|\__|
                 | |
                 |_|

  Unlike the BVHs for the individual objects, which act as our BAS, the TAS *is not relative to the world origin*!
  All coordinates are the final world coordinates derived from the BAS bounding boxes, after all transformations.
  In theory this might mean the TAS is not 100% accurate for objects far away from origin, but I think it should do
  fine as it is. If we really really really need that 100% accuracy, we'll just make it relative to the origin
 */
export declare class TopLevelAccelerationStructure {
    private debugBVH;
    private static cubeIndices;
    private static CUBE_VERTS;
    batchObjects: BatchObject[];
    bounds: Box3;
    accelerationStructure: AccelerationStructure;
    bvhHelper: MeshBVHVisualizer;
    constructor(batchObjects: BatchObject[]);
    private buildBVH;
    private updateVertArray;
    refit(): void;
    raycast(ray: Ray, tasOnly?: boolean, materialOrSide?: Side | Material | Material[]): ExtendedMeshIntersection[];
    raycastFirst(ray: Ray, tasOnly?: boolean, materialOrSide?: Side | Material | Material[]): ExtendedMeshIntersection | null;
    shapecast(callbacks: ExtendedShapeCastCallbacks): boolean;
    closestPointToPoint(point: Vector3): HitPointInfo | null;
    closestPointToPointHalfplane(point: Vector3, planeNormal: Vector3, fallback?: number, target?: HitPointInfo, minThreshold?: number, maxThreshold?: number): HitPointInfo | null;
    getBoundingBox(target: Box3): Box3;
}
