import { BufferGeometry, Matrix4, Vector3 } from 'three';
import { type SpeckleObject } from '../../IViewer.js';
export declare enum GeometryAttributes {
    POSITION = "POSITION",
    COLOR = "COLOR",
    NORMAL = "NORMAL",
    UV = "UV",
    TANGENT = "TANGENT",
    INDEX = "INDEX"
}
export interface GeometryData {
    attributes: (Record<GeometryAttributes.POSITION, number[]> & Partial<Record<GeometryAttributes, number[]>>) | null;
    bakeTransform: Matrix4 | null;
    transform: Matrix4 | null;
    metaData?: SpeckleObject;
    instanced?: boolean;
}
export declare class Geometry {
    private static readonly floatArrayBuff;
    static updateRTEGeometry(geometry: BufferGeometry, doublePositions: Float64Array | Float32Array): void;
    static mergeGeometryAttribute(attributes: (number[] | undefined)[], target: Float32Array | Float64Array): ArrayLike<number>;
    static mergeIndexAttribute(indexAttributes: (number[] | undefined)[], positionAttributes: (number[] | undefined)[]): number[];
    static mergeGeometryData(geometries: GeometryData[]): GeometryData;
    static transformGeometryData(geometryData: GeometryData, m: Matrix4 | null): void;
    static unpackColors(int32Colors: number[]): number[];
    /** Please see https://speckle.systems/blog/improving-speckles-rte-implementation/ for additional details
     *  regarding double -> <float low; float high> encoding.
     */
    static DoubleToHighLowVector(input: Vector3, low: Vector3, high: Vector3): void;
    static DoubleToHighLowBuffer(input: ArrayLike<number>, position_low: number[] | Float32Array, position_high: number[] | Float32Array): void;
    static computeVertexNormals(buffer: BufferGeometry, doublePositions: Float64Array): void;
}
